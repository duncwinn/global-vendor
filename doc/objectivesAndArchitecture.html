<html>
<head>
<link rel="stylesheet" type="text/css" href="docstyles.css"/>
</head>
<body>

<h1>Global Vendor</h1>
<h2>Objectives and Architecture</h2>
<p>
In this and subsequent blog posts I will be presenting a small project with the aim of showing how Spring Integration can be used to transparently create a distributed system.
</p>

<p>
This post describes the objectives of the project and the architectural design.
</p>
<p>
You can check out the code for this project at github:

<a href="https://github.com/mcintyred/global-vendor">Global Vendor</a>

</p>

<h3>Objectives</h3>

<p>
The overall objective is to create a simple stock management system based on the idea of warehouses, start with a traditional implementation using a central database and then gradually evolve a distributed system. So the order will be more or less to describe:
</p>

<ol>
<li>the business model and high-level architecture</li>
<li>an implementation using a local database</li>
<li>how to use Spring Integration and RabbitMQ to connect a remote system</li>
<li>implementing a remote system using Gemfire in both local-cache and client-server topologies</li>
<li>how to use Spring Batch to automate processing</li>
</ol>

<p>
Along the way I'll be using a variety of Spring projects and technologies in small bites, so if you haven't used them before I hope this will be a gentle introduction. Look out for Spring MVC, Spring Data JPA, Spring Data Gemfire, Spring Integration and Spring Batch.
</p>

<h3>
The Business Model
</h3>

<p>
So let's get started with a description of the 'business model' of our hypothetical Global Vendor (GV).
</p>

<p>
GV sells a variety of products to distributors throughout the world, and they have a number of warehouses in different locations. The list of products they sell is centrally managed, and warehouses are not required to hold stock of all products.
</p>

<p>
GV receives orders for products from their distributors and will fulfill an order by shipping product from one or more warehouses, starting with the warehouse with the most stock. The distributors are sent order confirmations which include a list of how many products are being shipped from each warehouse.
</p>

<h3>Requirements</h3>
<p>There will two users of the system - Administrators and Distributors.</p>

<p>
The Administrator must have access to a web interface which provides functionality to:
</p>

<ol>
<li>Register warehouses with the system.</li>
<li>Create new products in the local database.</li>
<li>Set stock levels for products across all registered warehouses.</li>
<li>View pending stock alerts.</li>
</ol>

<p>
Distributors must have access to a web interface which allows them to:
</p>

<ol>
<li>List all products in the database together with their total stock levels.</li>
<li>Place an order for a product and receive an acknowledgement.</li>
</ol>

<p>
Distributors must also be able to place orders using web-services or by placing an order file on an ftp server.
</p>

<p>
Finally, it must be possible to set a stock alert threshold for warehouses such that when stock of an item falls below the threshold an alert is sent back to the Administrator,
and when stock is replenished an update is sent back cancelling any previous alerts.
</p>

<p>
The rollout plan for the new system calls for a phased approach. 
<ul>

<li>
In the first phase, all stock information for all warehouses will be maintained in a central database, 

Distributors will be able to enter their orders manually through the website or by making a web-services request. 
</li>

<li>In the second phase warehouses will be able to maintain their own local stock database.</li>

<li>In the final phase distributors will be able to send batches of orders for offline processing by placing order files on an SFTP server.</li>
</ul>
</p>


<h3>Software Architecture</h3>
<p>
The overall architecture is shown below. Points to note are:
<ul>
<li>The AdminController is responsible for managing the product catalog and the list of registered warehouses, as well as setting stock levels at warehouses and reading stock alerts</li>
<li>The DistributorController talks directly to the DistributorService which is a facade hiding the details of the underlying services it delegates to.</li>
<li>There is a separate OrderService which is called by the DistributorService, the SOAP Gateway and eventually by Spring Batch components</li>
<li>The DistributedWarehouseService is responsible for directing calls to the appropriate WarehouseService; it must be aware of all the warehouses registered
with the system. WarehouseServices themselves can be local to the DistributedWarehouseService or remote, and Spring Integration allows us to make remote services appear local</li>
</ul>
</p>

<a name="softwareArchitecture-diagram"/>
<img src="softwareArchitecture.jpg" />

<h3>Systems Architecture</h3>

<p>
The second diagram - "Systems Architecture" - shows how the various implementations of the WarehouseService and other components are deployed. 
As you can see, I've deliberately made it as complicated as possible. 
If you run the code yourself it is of course possible to deploy the components in other ways. 
For example during testing I run the Gemfire Client and Server on Host 1.
</p>

<img src="systemsArchitecture.jpg" />

<p>
That's it for this post. In the next post I'll talk about the core code and show how to get a simple Host 1 only system up and running.
</p>


</body>
</html>